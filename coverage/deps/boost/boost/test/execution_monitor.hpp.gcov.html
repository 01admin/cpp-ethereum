<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - cov.data - deps/boost/boost/test/execution_monitor.hpp</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">deps/boost/boost/test</a> - execution_monitor.hpp<span style="font-size: 80%;"> (source / <a href="execution_monitor.hpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">cov.data</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntryLo">50.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-02-22 16:10:09</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : //  (C) Copyright Gennadiy Rozental 2001.</a>
<span class="lineNum">       2 </span>            : //  (C) Copyright Beman Dawes 2001.
<span class="lineNum">       3 </span>            : //  Distributed under the Boost Software License, Version 1.0.
<span class="lineNum">       4 </span>            : //  (See accompanying file LICENSE_1_0.txt or copy at
<span class="lineNum">       5 </span>            : //  http://www.boost.org/LICENSE_1_0.txt)
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : //  See http://www.boost.org/libs/test for the library home page.
<span class="lineNum">       8 </span>            : //
<span class="lineNum">       9 </span>            : //!@file
<span class="lineNum">      10 </span>            : //!@brief Defines public interface of the Execution Monitor and related classes
<span class="lineNum">      11 </span>            : // ***************************************************************************
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : #ifndef BOOST_TEST_EXECUTION_MONITOR_HPP_071894GER
<span class="lineNum">      14 </span>            : #define BOOST_TEST_EXECUTION_MONITOR_HPP_071894GER
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : // Boost.Test
<span class="lineNum">      17 </span>            : #include &lt;boost/test/detail/global_typedef.hpp&gt;
<span class="lineNum">      18 </span>            : #include &lt;boost/test/detail/fwd_decl.hpp&gt;
<span class="lineNum">      19 </span>            : #include &lt;boost/test/detail/throw_exception.hpp&gt;
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : #include &lt;boost/test/utils/class_properties.hpp&gt;
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            : // Boost
<span class="lineNum">      24 </span>            : #include &lt;boost/shared_ptr.hpp&gt;
<span class="lineNum">      25 </span>            : #include &lt;boost/scoped_array.hpp&gt;
<span class="lineNum">      26 </span>            : #include &lt;boost/type.hpp&gt;
<span class="lineNum">      27 </span>            : #include &lt;boost/cstdlib.hpp&gt;
<span class="lineNum">      28 </span>            : #include &lt;boost/function/function0.hpp&gt;
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : #include &lt;boost/test/detail/suppress_warnings.hpp&gt;
<span class="lineNum">      31 </span>            : 
<span class="lineNum">      32 </span>            : #ifdef BOOST_SEH_BASED_SIGNAL_HANDLING
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span>            : // for the FP constants and control routines
<span class="lineNum">      35 </span>            : #include &lt;float.h&gt;
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : #ifndef EM_INVALID
<span class="lineNum">      38 </span>            : #define EM_INVALID _EM_INVALID
<span class="lineNum">      39 </span>            : #endif
<span class="lineNum">      40 </span>            : 
<span class="lineNum">      41 </span>            : #ifndef EM_DENORMAL
<span class="lineNum">      42 </span>            : #define EM_DENORMAL _EM_DENORMAL
<span class="lineNum">      43 </span>            : #endif
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            : #ifndef EM_ZERODIVIDE
<span class="lineNum">      46 </span>            : #define EM_ZERODIVIDE _EM_ZERODIVIDE
<span class="lineNum">      47 </span>            : #endif
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            : #ifndef EM_OVERFLOW
<span class="lineNum">      50 </span>            : #define EM_OVERFLOW _EM_OVERFLOW
<span class="lineNum">      51 </span>            : #endif
<span class="lineNum">      52 </span>            : 
<span class="lineNum">      53 </span>            : #ifndef EM_UNDERFLOW
<span class="lineNum">      54 </span>            : #define EM_UNDERFLOW _EM_UNDERFLOW
<span class="lineNum">      55 </span>            : #endif
<span class="lineNum">      56 </span>            : 
<span class="lineNum">      57 </span>            : #ifndef MCW_EM
<span class="lineNum">      58 </span>            : #define MCW_EM _MCW_EM
<span class="lineNum">      59 </span>            : #endif
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span>            : #else // based on ISO C standard
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            : #if !defined(BOOST_NO_FENV_H)
<span class="lineNum">      64 </span>            :   #include &lt;boost/detail/fenv.hpp&gt;
<span class="lineNum">      65 </span>            : #endif
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            : #endif
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span>            : // Additional macro documentations not being generated without this hack
<span class="lineNum">      71 </span>            : #ifdef BOOST_TEST_DOXYGEN_DOC__
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span>            : //! Disables the support of the alternative stack
<span class="lineNum">      74 </span>            : //! during the compilation of the Boost.test framework. This is especially useful
<span class="lineNum">      75 </span>            : //! in case it is not possible to detect the lack of alternative stack support for
<span class="lineNum">      76 </span>            : //! your compiler (for instance, ESXi).
<span class="lineNum">      77 </span>            : #define BOOST_TEST_DISABLE_ALT_STACK
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            : #endif
<span class="lineNum">      80 </span>            : 
<span class="lineNum">      81 </span>            : //____________________________________________________________________________//
<span class="lineNum">      82 </span>            : 
<span class="lineNum">      83 </span>            : namespace boost {
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span>            : /// @defgroup ExecutionMonitor Function Execution Monitor
<span class="lineNum">      86 </span>            : /// @{
<span class="lineNum">      87 </span>            : /// @section Intro Introduction
<span class="lineNum">      88 </span>            : /// Sometimes we need to call a function and make sure that no user or system originated exceptions are being thrown by it. Uniform exception reporting
<span class="lineNum">      89 </span>            : /// is also may be convenient. That's the purpose of the Boost.Test's Execution Monitor.
<span class="lineNum">      90 </span>            : ///
<span class="lineNum">      91 </span>            : /// The Execution Monitor is a lower-level component of the Boost Test Library. It is the base for implementing all other Boost.Test components, but also
<span class="lineNum">      92 </span>            : /// can be used standalone to get controlled execution of error-prone functions with a uniform error notification. The Execution Monitor calls a user-supplied
<span class="lineNum">      93 </span>            : /// function in a controlled environment, relieving users from messy error detection.
<span class="lineNum">      94 </span>            : ///
<span class="lineNum">      95 </span>            : /// The Execution Monitor usage is demonstrated in the example exec_mon_example.
<span class="lineNum">      96 </span>            : ///
<span class="lineNum">      97 </span>            : /// @section DesignRationale Design Rationale
<span class="lineNum">      98 </span>            : ///
<span class="lineNum">      99 </span>            : /// The Execution Monitor design assumes that it can be used when no (or almost no) memory available. Also the Execution Monitor is intended to be portable to as many platforms as possible.
<span class="lineNum">     100 </span>            : ///
<span class="lineNum">     101 </span>            : /// @section UserGuide User's guide
<span class="lineNum">     102 </span>            : /// The Execution Monitor is designed to solve the problem of executing potentially dangerous function that may result in any number of error conditions,
<span class="lineNum">     103 </span>            : /// in monitored environment that should prevent any undesirable exceptions to propagate out of function call and produce consistent result report for all outcomes.
<span class="lineNum">     104 </span>            : /// The Execution Monitor is able to produce informative report for all standard C++ exceptions and intrinsic types. All other exceptions are reported as unknown.
<span class="lineNum">     105 </span>            : /// If you prefer different message for your exception type or need to perform any action, the Execution Monitor supports custom exception translators.
<span class="lineNum">     106 </span>            : /// There are several other parameters of the monitored environment can be configured by setting appropriate properties of the Execution Monitor.
<span class="lineNum">     107 </span>            : ///
<span class="lineNum">     108 </span>            : /// All symbols in the Execution Monitor implementation are located in the namespace boost. To use the Execution Monitor you need to:
<span class="lineNum">     109 </span>            : /// -# include @c boost/test/execution_monitor.hpp
<span class="lineNum">     110 </span>            : /// -# Make an instance of execution_monitor.
<span class="lineNum">     111 </span>            : /// -# Optionally register custom exception translators for exception classes which require special processing.
<span class="lineNum">     112 </span>            : ///
<span class="lineNum">     113 </span>            : /// @subsection FuncExec Monitored function execution
<span class="lineNum">     114 </span>            : ///
<span class="lineNum">     115 </span>            : /// The class execution_monitor can monitor functions with the following signatures:
<span class="lineNum">     116 </span>            : /// - int ()
<span class="lineNum">     117 </span>            : /// - void ()
<span class="lineNum">     118 </span>            : ///
<span class="lineNum">     119 </span>            : /// This function is expected to be self sufficient part of your application. You can't pass any arguments to this function directly. Instead you
<span class="lineNum">     120 </span>            : /// should bind them into executable nullary function using bind function (either standard or boost variant). Neither you can return any other value,
<span class="lineNum">     121 </span>            : /// but an integer result code. If necessary you can bind output parameters by reference or use some other more complicated nullary functor, which
<span class="lineNum">     122 </span>            : /// maintains state. This includes class methods, static class methods etc.
<span class="lineNum">     123 </span>            : ///
<span class="lineNum">     124 </span>            : /// To start the monitored function, invoke the method execution_monitor::execute and pass the monitored function as an argument. If the call succeeds,
<span class="lineNum">     125 </span>            : /// the method returns the result code produced by the monitored function. If any of the following conditions occur:
<span class="lineNum">     126 </span>            : /// - Uncaught C++ exception
<span class="lineNum">     127 </span>            : /// - Hardware or software signal, trap, or other exception
<span class="lineNum">     128 </span>            : /// - Timeout reached
<span class="lineNum">     129 </span>            : /// - Debug assert event occurred (under Microsoft Visual C++ or compatible compiler)
<span class="lineNum">     130 </span>            : ///
<span class="lineNum">     131 </span>            : /// then the method throws the execution_exception. The exception contains unique error_code value identifying the error condition and the detailed message
<span class="lineNum">     132 </span>            : /// that can be used to report the error.
<span class="lineNum">     133 </span>            : ///
<span class="lineNum">     134 </span>            : /// @subsection Reporting Errors reporting and translation
<span class="lineNum">     135 </span>            : ///
<span class="lineNum">     136 </span>            : /// If you need to report an error inside monitored function execution you have to throw an exception. Do not use the execution_exception - it's not intended
<span class="lineNum">     137 </span>            : /// to be used for this purpose. The simplest choice is to use one of the following C++ types as an exception:
<span class="lineNum">     138 </span>            : /// - C string
<span class="lineNum">     139 </span>            : /// - std:string
<span class="lineNum">     140 </span>            : /// - any exception class in std::exception hierarchy
<span class="lineNum">     141 </span>            : /// - boost::exception
<span class="lineNum">     142 </span>            : ///
<span class="lineNum">     143 </span>            : /// execution_monitor will catch and report these types of exceptions. If exception is thrown which is unknown to execution_monitor, it can only
<span class="lineNum">     144 </span>            : /// report the fact of the exception. So in case if you prefer to use your own exception types or can't govern what exceptions are generated by monitored
<span class="lineNum">     145 </span>            : /// function and would like to see proper error message in a report, execution_monitor can be configured with custom &quot;translator&quot; routine, which will have
<span class="lineNum">     146 </span>            : /// a chance to either record the fact of the exception itself or translate it into one of standard exceptions and rethrow (or both). The translator routine
<span class="lineNum">     147 </span>            : /// is registered per exception type and is invoked when exception of this class (or one inherited from it) is thrown inside monitored routine. You can
<span class="lineNum">     148 </span>            : /// register as many independent translators as you like. See execution_monitor::register_exception_translator specification for requirements on translator
<span class="lineNum">     149 </span>            : /// function.
<span class="lineNum">     150 </span>            : ///
<span class="lineNum">     151 </span>            : /// Finally, if you need to abort the monitored function execution without reporting any errors, you can throw an exception execution_aborted. As a result
<span class="lineNum">     152 </span>            : /// the execution is aborted and zero result code is produced by the method execution_monitor::execute.
<span class="lineNum">     153 </span>            : ///
<span class="lineNum">     154 </span>            : /// @subsection Parameters Supported parameters
<span class="lineNum">     155 </span>            : ///
<span class="lineNum">     156 </span>            : /// The Execution Monitor behavior is configurable through the set of parameters (properties) associated with the instance of the monitor. See execution_monitor
<span class="lineNum">     157 </span>            : /// specification for a list of supported parameters and their semantic.
<span class="lineNum">     158 </span>            : 
<span class="lineNum">     159 </span>            : // ************************************************************************** //
<span class="lineNum">     160 </span>            : // **************        detail::translator_holder_base        ************** //
<span class="lineNum">     161 </span>            : // ************************************************************************** //
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span>            : namespace detail {
<span class="lineNum">     164 </span>            : 
<span class="lineNum">     165 </span>            : class translator_holder_base;
<span class="lineNum">     166 </span>            : typedef boost::shared_ptr&lt;translator_holder_base&gt; translator_holder_base_ptr;
<span class="lineNum">     167 </span>            : 
<span class="lineNum">     168 </span>            : class BOOST_TEST_DECL translator_holder_base {
<span class="lineNum">     169 </span>            : protected:
<span class="lineNum">     170 </span>            :     typedef boost::unit_test::const_string const_string;
<span class="lineNum">     171 </span>            : public:
<span class="lineNum">     172 </span>            :     // Constructor
<span class="lineNum">     173 </span>            :     translator_holder_base( translator_holder_base_ptr next, const_string tag )
<span class="lineNum">     174 </span>            :     : m_next( next )
<span class="lineNum">     175 </span>            :     , m_tag( std::string() + tag )
<span class="lineNum">     176 </span>            :     {
<span class="lineNum">     177 </span>            :     }
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span>            :     // Destructor
<span class="lineNum">     180 </span>            :     virtual     ~translator_holder_base() {}
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span>            :     // translator holder interface
<span class="lineNum">     183 </span>            :     // invokes the function F inside the try/catch guarding against specific exception
<span class="lineNum">     184 </span>            :     virtual int operator()( boost::function&lt;int ()&gt; const&amp; F ) = 0;
<span class="lineNum">     185 </span>            : 
<span class="lineNum">     186 </span>            :     // erases specific translator holder from the chain
<span class="lineNum">     187 </span>            :     translator_holder_base_ptr erase( translator_holder_base_ptr this_, const_string tag )
<span class="lineNum">     188 </span>            :     {
<span class="lineNum">     189 </span>            :         if( m_next )
<span class="lineNum">     190 </span>            :             m_next = m_next-&gt;erase( m_next, tag );
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span>            :         return m_tag == tag ? m_next : this_;
<span class="lineNum">     193 </span>            :     }
<span class="lineNum">     194 </span>            : #ifndef BOOST_NO_RTTI
<span class="lineNum">     195 </span>            :     virtual translator_holder_base_ptr erase( translator_holder_base_ptr this_, std::type_info const&amp; ) = 0;
<span class="lineNum">     196 </span>            :     template&lt;typename ExceptionType&gt;
<span class="lineNum">     197 </span>            :     translator_holder_base_ptr erase( translator_holder_base_ptr this_, boost::type&lt;ExceptionType&gt;* = 0 )
<span class="lineNum">     198 </span>            :     {
<span class="lineNum">     199 </span>            :         if( m_next )
<span class="lineNum">     200 </span>            :             m_next = m_next-&gt;erase&lt;ExceptionType&gt;( m_next );
<span class="lineNum">     201 </span>            : 
<span class="lineNum">     202 </span>            :         return erase( this_, typeid(ExceptionType) );
<span class="lineNum">     203 </span>            :     }
<span class="lineNum">     204 </span>            : #endif
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span>            : protected:
<span class="lineNum">     207 </span>            :     // Data members
<span class="lineNum">     208 </span>            :     translator_holder_base_ptr  m_next;
<span class="lineNum">     209 </span>            :     std::string                 m_tag;
<span class="lineNum">     210 </span>            : };
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span>            : } // namespace detail
<span class="lineNum">     213 </span>            : 
<span class="lineNum">     214 </span>            : // ************************************************************************** //
<span class="lineNum">     215 </span>            : /// @class execution_exception
<span class="lineNum">     216 </span>            : /// @brief This class is used to report any kind of an failure during execution of a monitored function inside of execution_monitor
<span class="lineNum">     217 </span>            : ///
<span class="lineNum">     218 </span>            : /// The instance of this class is thrown out of execution_monitor::execute invocation when failure is detected. Regardless of a kind of failure occurred
<span class="lineNum">     219 </span>            : /// the instance will provide a uniform way to catch and report it.
<span class="lineNum">     220 </span>            : ///
<span class="lineNum">     221 </span>            : /// One important design rationale for this class is that we should be ready to work after fatal memory corruptions or out of memory conditions. To facilitate
<span class="lineNum">     222 </span>            : /// this class never allocates any memory and assumes that strings it refers to are either some constants or live in a some kind of persistent (preallocated) memory.
<span class="lineNum">     223 </span>            : // ************************************************************************** //
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span>            : class BOOST_TEST_DECL execution_exception {
<span class="lineNum">     226 </span>            :     typedef boost::unit_test::const_string const_string;
<span class="lineNum">     227 </span>            : public:
<span class="lineNum">     228 </span>            :     /// These values are sometimes used as program return codes.
<span class="lineNum">     229 </span>            :     /// The particular values have been chosen to avoid conflicts with
<span class="lineNum">     230 </span>            :     /// commonly used program return codes: values &lt; 100 are often user
<span class="lineNum">     231 </span>            :     /// assigned, values &gt; 255 are sometimes used to report system errors.
<span class="lineNum">     232 </span>            :     /// Gaps in values allow for orderly expansion.
<span class="lineNum">     233 </span>            :     ///
<span class="lineNum">     234 </span>            :     /// @note(1) Only uncaught C++ exceptions are treated as errors.
<span class="lineNum">     235 </span>            :     /// If a function catches a C++ exception, it never reaches
<span class="lineNum">     236 </span>            :     /// the execution_monitor.
<span class="lineNum">     237 </span>            :     ///
<span class="lineNum">     238 </span>            :     /// The implementation decides what is a system_fatal_error and what is
<span class="lineNum">     239 </span>            :     /// just a system_exception. Fatal errors are so likely to have corrupted
<span class="lineNum">     240 </span>            :     /// machine state (like a stack overflow or addressing exception) that it
<span class="lineNum">     241 </span>            :     /// is unreasonable to continue execution.
<span class="lineNum">     242 </span>            :     ///
<span class="lineNum">     243 </span>            :     /// @note(2) These errors include Unix signals and Windows structured
<span class="lineNum">     244 </span>            :     /// exceptions. They are often initiated by hardware traps.
<span class="lineNum">     245 </span>            :     enum error_code {
<span class="lineNum">     246 </span>            :         no_error               = 0,   ///&lt; for completeness only; never returned
<span class="lineNum">     247 </span>            :         user_error             = 200, ///&lt; user reported non-fatal error
<span class="lineNum">     248 </span>            :         cpp_exception_error    = 205, ///&lt; see note (1) above
<span class="lineNum">     249 </span>            :         system_error           = 210, ///&lt; see note (2) above
<span class="lineNum">     250 </span>            :         timeout_error          = 215, ///&lt; only detectable on certain platforms
<span class="lineNum">     251 </span>            :         user_fatal_error       = 220, ///&lt; user reported fatal error
<span class="lineNum">     252 </span>            :         system_fatal_error     = 225  ///&lt; see note (2) above
<span class="lineNum">     253 </span>            :     };
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span>            :     /// Simple model for the location of failure in a source code
<span class="lineNum">     256 </span>            :     struct BOOST_TEST_DECL location {
<span class="lineNum">     257 </span>            :         explicit    location( char const* file_name = 0, size_t line_num = 0, char const* func = 0 );
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span>            :         const_string    m_file_name;    ///&lt; File name
<span class="lineNum">     260 </span>            :         size_t          m_line_num;     ///&lt; Line number
<span class="lineNum">     261 </span>            :         const_string    m_function;     ///&lt; Function name
<span class="lineNum">     262 </span>            :     };
<span class="lineNum">     263 </span>            : 
<span class="lineNum">     264 </span>            :     /// @name Constructors
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span>            :     /// Constructs instance based on message, location and error code
<span class="lineNum">     267 </span>            : 
<span class="lineNum">     268 </span>            :     /// @param[in] ec           error code
<span class="lineNum">     269 </span>            :     /// @param[in] what_msg     error message
<span class="lineNum">     270 </span>            :     /// @param[in] location     error location
<span class="lineNum">     271 </span>            :     execution_exception( error_code ec, const_string what_msg, location const&amp; location );
<span class="lineNum">     272 </span>            : 
<span class="lineNum">     273 </span>            :     /// @name Access methods
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span>            :     /// Exception error code
<span class="lineNum">     276 </span>            :     error_code      code() const    { return m_error_code; }
<span class="lineNum">     277 </span>            :     /// Exception message
<span class="lineNum">     278 </span>            :     const_string    what() const    { return m_what; }
<span class="lineNum">     279 </span>            :     /// Exception location
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :     location const&amp; where() const   { return m_location; }</span>
<span class="lineNum">     281 </span>            :     ///@}
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span>            : private:
<span class="lineNum">     284 </span>            :     // Data members
<span class="lineNum">     285 </span>            :     error_code      m_error_code;
<span class="lineNum">     286 </span>            :     const_string    m_what;
<span class="lineNum">     287 </span>            :     location        m_location;
<span class="lineNum">     288 </span>            : }; // execution_exception
<span class="lineNum">     289 </span>            : 
<span class="lineNum">     290 </span>            : // ************************************************************************** //
<span class="lineNum">     291 </span>            : /// @brief Function execution monitor
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span>            : /// This class is used to uniformly detect and report an occurrence of several types of signals and exceptions, reducing various
<span class="lineNum">     294 </span>            : /// errors to a uniform execution_exception that is returned to a caller.
<span class="lineNum">     295 </span>            : ///
<span class="lineNum">     296 </span>            : /// The executiom_monitor behavior can be customized through a set of public parameters (properties) associated with the execution_monitor instance.
<span class="lineNum">     297 </span>            : /// All parameters are implemented as public unit_test::readwrite_property data members of the class execution_monitor.
<a name="298"><span class="lineNum">     298 </span>            : // ************************************************************************** //</a>
<span class="lineNum">     299 </span>            : 
<span class="lineNum">     300 </span><span class="lineCov">          6 : class BOOST_TEST_DECL execution_monitor {</span>
<span class="lineNum">     301 </span>            :     typedef boost::unit_test::const_string const_string;
<span class="lineNum">     302 </span>            : public:
<span class="lineNum">     303 </span>            : 
<span class="lineNum">     304 </span>            :     /// Default constructor initializes all execution monitor properties
<span class="lineNum">     305 </span>            :     execution_monitor();
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span>            :     /// Should monitor catch system errors.
<span class="lineNum">     308 </span>            :     ///
<span class="lineNum">     309 </span>            :     /// The @em p_catch_system_errors property is a boolean flag (default value is true) specifying whether or not execution_monitor should trap system
<span class="lineNum">     310 </span>            :     /// errors/system level exceptions/signals, which would cause program to crash in a regular case (without execution_monitor).
<span class="lineNum">     311 </span>            :     /// Set this property to false, for example, if you wish to force coredump file creation. The Unit Test Framework provides a
<span class="lineNum">     312 </span>            :     /// runtime parameter @c \-\-catch_system_errors=yes to alter the behavior in monitored test cases.
<span class="lineNum">     313 </span>            :     unit_test::readwrite_property&lt;bool&gt; p_catch_system_errors;
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span>            :     ///  Should monitor try to attach debugger in case of caught system error.
<span class="lineNum">     316 </span>            :     ///
<span class="lineNum">     317 </span>            :     /// The @em p_auto_start_dbg property is a boolean flag (default value is false) specifying whether or not execution_monitor should try to attach debugger
<span class="lineNum">     318 </span>            :     /// in case system error is caught.
<span class="lineNum">     319 </span>            :     unit_test::readwrite_property&lt;bool&gt; p_auto_start_dbg;
<span class="lineNum">     320 </span>            : 
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span>            :     ///  Specifies the seconds that elapse before a timer_error occurs.
<span class="lineNum">     323 </span>            :     ///
<span class="lineNum">     324 </span>            :     /// The @em p_timeout property is an integer timeout (in seconds) for monitored function execution. Use this parameter to monitor code with possible deadlocks
<span class="lineNum">     325 </span>            :     /// or indefinite loops. This feature is only available for some operating systems (not yet Microsoft Windows).
<span class="lineNum">     326 </span>            :     unit_test::readwrite_property&lt;unsigned&gt;  p_timeout;
<span class="lineNum">     327 </span>            : 
<span class="lineNum">     328 </span>            :     ///  Should monitor use alternative stack for the signal catching.
<span class="lineNum">     329 </span>            :     ///
<span class="lineNum">     330 </span>            :     /// The @em p_use_alt_stack property is a boolean flag (default value is false) specifying whether or not execution_monitor should use an alternative stack
<span class="lineNum">     331 </span>            :     /// for the sigaction based signal catching. When enabled the signals are delivered to the execution_monitor on a stack different from current execution
<span class="lineNum">     332 </span>            :     /// stack, which is safer in case if it is corrupted by monitored function. For more details on alternative stack handling see appropriate manuals.
<span class="lineNum">     333 </span>            :     unit_test::readwrite_property&lt;bool&gt; p_use_alt_stack;
<span class="lineNum">     334 </span>            : 
<span class="lineNum">     335 </span>            :     /// Should monitor try to detect hardware floating point exceptions (!= 0), and which specific exception to catch.
<span class="lineNum">     336 </span>            :     ///
<span class="lineNum">     337 </span>            :     /// The @em p_detect_fp_exceptions property is a boolean flag (default value is false) specifying whether or not execution_monitor should install hardware
<span class="lineNum">     338 </span>            :     /// traps for the floating point exception on platforms where it's supported.
<span class="lineNum">     339 </span>            :     unit_test::readwrite_property&lt;unsigned&gt; p_detect_fp_exceptions;
<span class="lineNum">     340 </span>            : 
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span>            :     // @name Monitoring entry points
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span>            :     /// @brief Execution monitor entry point for functions returning integer value
<span class="lineNum">     345 </span>            :     ///
<span class="lineNum">     346 </span>            :     /// This method executes supplied function F inside a try/catch block and also may include other unspecified platform dependent error detection code.
<span class="lineNum">     347 </span>            :     ///
<span class="lineNum">     348 </span>            :     /// This method throws an execution_exception on an uncaught C++ exception, a hardware or software signal, trap, or other user exception.
<span class="lineNum">     349 </span>            :     ///
<span class="lineNum">     350 </span>            :     /// @note execute() doesn't consider it an error for F to return a non-zero value.
<span class="lineNum">     351 </span>            :     /// @param[in] F  Function to monitor
<span class="lineNum">     352 </span>            :     /// @returns  value returned by function call F().
<span class="lineNum">     353 </span>            :     /// @see vexecute
<span class="lineNum">     354 </span>            :     int         execute( boost::function&lt;int ()&gt; const&amp; F );
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span>            :     /// @brief Execution monitor entry point for functions returning void
<span class="lineNum">     357 </span>            :     ///
<span class="lineNum">     358 </span>            :     /// This method is semantically identical to execution_monitor::execute, but des't produce any result code.
<span class="lineNum">     359 </span>            :     /// @param[in] F  Function to monitor
<span class="lineNum">     360 </span>            :     /// @see execute
<span class="lineNum">     361 </span>            :     void         vexecute( boost::function&lt;void ()&gt; const&amp; F );
<span class="lineNum">     362 </span>            :     // @}
<span class="lineNum">     363 </span>            : 
<span class="lineNum">     364 </span>            :     // @name Exception translator registration
<span class="lineNum">     365 </span>            : 
<span class="lineNum">     366 </span>            :     /// @brief Registers custom (user supplied) exception translator
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span>            :     /// This method template registers a translator for an exception type specified as a first template argument. For example
<span class="lineNum">     369 </span>            :     /// @code
<span class="lineNum">     370 </span>            :     ///    void myExceptTr( MyException const&amp; ex ) { /*do something with the exception here*/}
<span class="lineNum">     371 </span>            :     ///    em.register_exception_translator&lt;MyException&gt;( myExceptTr );
<span class="lineNum">     372 </span>            :     /// @endcode
<span class="lineNum">     373 </span>            :     /// The translator should be any unary function/functor object which accepts MyException const&amp;. This can be free standing function
<span class="lineNum">     374 </span>            :     /// or bound class method. The second argument is an optional string tag you can associate with this translator routine. The only reason
<span class="lineNum">     375 </span>            :     /// to specify the tag is if you plan to erase the translator eventually. This can be useful in scenario when you reuse the same
<span class="lineNum">     376 </span>            :     /// execution_monitor instance to monitor different routines and need to register a translator specific to the routine being monitored.
<span class="lineNum">     377 </span>            :     /// While it is possible to erase the translator based on an exception type it was registered for, tag string provides simpler way of doing this.
<span class="lineNum">     378 </span>            :     /// @tparam ExceptionType type of the exception we register a translator for
<span class="lineNum">     379 </span>            :     /// @tparam ExceptionTranslator type of the translator we register for this exception
<span class="lineNum">     380 </span>            :     /// @param[in] tr         translator function object with the signature &lt;em&gt; void (ExceptionType const&amp;)&lt;/em&gt;
<span class="lineNum">     381 </span>            :     /// @param[in] tag        tag associated with this translator
<span class="lineNum">     382 </span>            :     template&lt;typename ExceptionType, typename ExceptionTranslator&gt;
<span class="lineNum">     383 </span>            :     void        register_exception_translator( ExceptionTranslator const&amp; tr, const_string tag = const_string(), boost::type&lt;ExceptionType&gt;* = 0 );
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span>            :     /// @brief Erases custom exception translator based on a tag
<span class="lineNum">     386 </span>            : 
<span class="lineNum">     387 </span>            :     /// Use the same tag as the one used during translator registration
<span class="lineNum">     388 </span>            :     /// @param[in] tag  tag associated with translator you wants to erase
<span class="lineNum">     389 </span>            :     void        erase_exception_translator( const_string tag )
<span class="lineNum">     390 </span>            :     {
<span class="lineNum">     391 </span>            :         m_custom_translators = m_custom_translators-&gt;erase( m_custom_translators, tag );
<span class="lineNum">     392 </span>            :     }
<span class="lineNum">     393 </span>            : #ifndef BOOST_NO_RTTI
<span class="lineNum">     394 </span>            :     /// @brief Erases custom exception translator based on an exception type
<span class="lineNum">     395 </span>            :     ///
<span class="lineNum">     396 </span>            :     /// tparam ExceptionType Exception type for which you want to erase the translator
<span class="lineNum">     397 </span>            :     template&lt;typename ExceptionType&gt;
<span class="lineNum">     398 </span>            :     void        erase_exception_translator( boost::type&lt;ExceptionType&gt;* = 0 )
<span class="lineNum">     399 </span>            :     {
<span class="lineNum">     400 </span>            :         m_custom_translators = m_custom_translators-&gt;erase&lt;ExceptionType&gt;( m_custom_translators );
<span class="lineNum">     401 </span>            :     }
<span class="lineNum">     402 </span>            :     //@}
<span class="lineNum">     403 </span>            : #endif
<span class="lineNum">     404 </span>            : 
<span class="lineNum">     405 </span>            : private:
<span class="lineNum">     406 </span>            :     // implementation helpers
<span class="lineNum">     407 </span>            :     int         catch_signals( boost::function&lt;int ()&gt; const&amp; F );
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span>            :     // Data members
<span class="lineNum">     410 </span>            :     detail::translator_holder_base_ptr  m_custom_translators;
<span class="lineNum">     411 </span>            :     boost::scoped_array&lt;char&gt;           m_alt_stack;
<span class="lineNum">     412 </span>            : }; // execution_monitor
<span class="lineNum">     413 </span>            : 
<span class="lineNum">     414 </span>            : // ************************************************************************** //
<span class="lineNum">     415 </span>            : // **************          detail::translator_holder           ************** //
<span class="lineNum">     416 </span>            : // ************************************************************************** //
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span>            : namespace detail {
<span class="lineNum">     419 </span>            : 
<span class="lineNum">     420 </span>            : template&lt;typename ExceptionType, typename ExceptionTranslator&gt;
<span class="lineNum">     421 </span>            : class translator_holder : public translator_holder_base
<span class="lineNum">     422 </span>            : {
<span class="lineNum">     423 </span>            : public:
<span class="lineNum">     424 </span>            :     explicit    translator_holder( ExceptionTranslator const&amp; tr, translator_holder_base_ptr&amp; next, const_string tag = const_string() )
<span class="lineNum">     425 </span>            :     : translator_holder_base( next, tag ), m_translator( tr ) {}
<span class="lineNum">     426 </span>            : 
<span class="lineNum">     427 </span>            :     // translator holder interface
<span class="lineNum">     428 </span>            :     virtual int operator()( boost::function&lt;int ()&gt; const&amp; F )
<span class="lineNum">     429 </span>            :     {
<span class="lineNum">     430 </span>            :         BOOST_TEST_I_TRY {
<span class="lineNum">     431 </span>            :             return m_next ? (*m_next)( F ) : F();
<span class="lineNum">     432 </span>            :         }
<span class="lineNum">     433 </span>            :         BOOST_TEST_I_CATCH( ExceptionType, e ) {
<span class="lineNum">     434 </span>            :             m_translator( e );
<span class="lineNum">     435 </span>            :             return boost::exit_exception_failure;
<span class="lineNum">     436 </span>            :         }
<span class="lineNum">     437 </span>            :     }
<span class="lineNum">     438 </span>            : #ifndef BOOST_NO_RTTI
<span class="lineNum">     439 </span>            :     virtual translator_holder_base_ptr erase( translator_holder_base_ptr this_, std::type_info const&amp; ti )
<span class="lineNum">     440 </span>            :     {
<span class="lineNum">     441 </span>            :         return ti == typeid(ExceptionType) ? m_next : this_;
<span class="lineNum">     442 </span>            :     }
<span class="lineNum">     443 </span>            : #endif
<span class="lineNum">     444 </span>            : 
<span class="lineNum">     445 </span>            : private:
<span class="lineNum">     446 </span>            :     // Data members
<span class="lineNum">     447 </span>            :     ExceptionTranslator m_translator;
<span class="lineNum">     448 </span>            : };
<span class="lineNum">     449 </span>            : 
<span class="lineNum">     450 </span>            : } // namespace detail
<span class="lineNum">     451 </span>            : 
<span class="lineNum">     452 </span>            : template&lt;typename ExceptionType, typename ExceptionTranslator&gt;
<span class="lineNum">     453 </span>            : void
<span class="lineNum">     454 </span>            : execution_monitor::register_exception_translator( ExceptionTranslator const&amp; tr, const_string tag, boost::type&lt;ExceptionType&gt;* )
<span class="lineNum">     455 </span>            : {
<span class="lineNum">     456 </span>            :     m_custom_translators.reset(
<span class="lineNum">     457 </span>            :         new detail::translator_holder&lt;ExceptionType,ExceptionTranslator&gt;( tr, m_custom_translators, tag ) );
<span class="lineNum">     458 </span>            : }
<span class="lineNum">     459 </span>            : 
<span class="lineNum">     460 </span>            : // ************************************************************************** //
<span class="lineNum">     461 </span>            : /// @class execution_aborted
<span class="lineNum">     462 </span>            : /// @brief This is a trivial default constructible class. Use it to report graceful abortion of a monitored function execution.
<span class="lineNum">     463 </span>            : // ************************************************************************** //
<span class="lineNum">     464 </span>            : 
<span class="lineNum">     465 </span>            : struct execution_aborted {};
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span>            : // ************************************************************************** //
<span class="lineNum">     468 </span>            : // **************                  system_error                ************** //
<span class="lineNum">     469 </span>            : // ************************************************************************** //
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span>            : class system_error {
<span class="lineNum">     472 </span>            : public:
<span class="lineNum">     473 </span>            :     // Constructor
<span class="lineNum">     474 </span>            :     explicit    system_error( char const* exp );
<span class="lineNum">     475 </span>            : 
<span class="lineNum">     476 </span>            :     long const          p_errno;
<span class="lineNum">     477 </span>            :     char const* const   p_failed_exp;
<span class="lineNum">     478 </span>            : };
<span class="lineNum">     479 </span>            : 
<span class="lineNum">     480 </span>            : //!@internal
<span class="lineNum">     481 </span>            : #define BOOST_TEST_SYS_ASSERT( cond ) BOOST_TEST_I_ASSRT( cond, ::boost::system_error( BOOST_STRINGIZE( exp ) ) )
<span class="lineNum">     482 </span>            : 
<span class="lineNum">     483 </span>            : // ************************************************************************** //
<span class="lineNum">     484 </span>            : // **************Floating point exception management interface ************** //
<span class="lineNum">     485 </span>            : // ************************************************************************** //
<span class="lineNum">     486 </span>            : 
<span class="lineNum">     487 </span>            : namespace fpe {
<span class="lineNum">     488 </span>            : 
<span class="lineNum">     489 </span>            : enum masks {
<span class="lineNum">     490 </span>            :     BOOST_FPE_OFF       = 0,
<span class="lineNum">     491 </span>            : 
<span class="lineNum">     492 </span>            : #ifdef BOOST_SEH_BASED_SIGNAL_HANDLING /* *** */
<span class="lineNum">     493 </span>            :     BOOST_FPE_DIVBYZERO = EM_ZERODIVIDE,
<span class="lineNum">     494 </span>            :     BOOST_FPE_INEXACT   = EM_INEXACT,
<span class="lineNum">     495 </span>            :     BOOST_FPE_INVALID   = EM_INVALID,
<span class="lineNum">     496 </span>            :     BOOST_FPE_OVERFLOW  = EM_OVERFLOW,
<span class="lineNum">     497 </span>            :     BOOST_FPE_UNDERFLOW = EM_UNDERFLOW|EM_DENORMAL,
<span class="lineNum">     498 </span>            : 
<span class="lineNum">     499 </span>            :     BOOST_FPE_ALL       = MCW_EM,
<span class="lineNum">     500 </span>            : 
<span class="lineNum">     501 </span>            : #elif defined(BOOST_NO_FENV_H) || defined(BOOST_CLANG) /* *** */
<span class="lineNum">     502 </span>            :     BOOST_FPE_ALL       = BOOST_FPE_OFF,
<span class="lineNum">     503 </span>            : 
<span class="lineNum">     504 </span>            : #else /* *** */
<span class="lineNum">     505 </span>            : 
<span class="lineNum">     506 </span>            : #if defined(FE_DIVBYZERO)
<span class="lineNum">     507 </span>            :     BOOST_FPE_DIVBYZERO = FE_DIVBYZERO,
<span class="lineNum">     508 </span>            : #else
<span class="lineNum">     509 </span>            :     BOOST_FPE_DIVBYZERO = BOOST_FPE_OFF,
<span class="lineNum">     510 </span>            : #endif
<span class="lineNum">     511 </span>            : 
<span class="lineNum">     512 </span>            : #if defined(FE_INEXACT)
<span class="lineNum">     513 </span>            :     BOOST_FPE_INEXACT   = FE_INEXACT,
<span class="lineNum">     514 </span>            : #else
<span class="lineNum">     515 </span>            :     BOOST_FPE_INEXACT   = BOOST_FPE_OFF,
<span class="lineNum">     516 </span>            : #endif
<span class="lineNum">     517 </span>            : 
<span class="lineNum">     518 </span>            : #if defined(FE_INVALID)
<span class="lineNum">     519 </span>            :     BOOST_FPE_INVALID   = FE_INVALID,
<span class="lineNum">     520 </span>            : #else
<span class="lineNum">     521 </span>            :     BOOST_FPE_INVALID   = BOOST_FPE_OFF,
<span class="lineNum">     522 </span>            : #endif
<span class="lineNum">     523 </span>            : 
<span class="lineNum">     524 </span>            : #if defined(FE_OVERFLOW)
<span class="lineNum">     525 </span>            :     BOOST_FPE_OVERFLOW  = FE_OVERFLOW,
<span class="lineNum">     526 </span>            : #else
<span class="lineNum">     527 </span>            :     BOOST_FPE_OVERFLOW  = BOOST_FPE_OFF,
<span class="lineNum">     528 </span>            : #endif
<span class="lineNum">     529 </span>            : 
<span class="lineNum">     530 </span>            : #if defined(FE_UNDERFLOW)
<span class="lineNum">     531 </span>            :     BOOST_FPE_UNDERFLOW = FE_UNDERFLOW,
<span class="lineNum">     532 </span>            : #else
<span class="lineNum">     533 </span>            :     BOOST_FPE_UNDERFLOW = BOOST_FPE_OFF,
<span class="lineNum">     534 </span>            : #endif
<span class="lineNum">     535 </span>            : 
<span class="lineNum">     536 </span>            : #if defined(FE_ALL_EXCEPT)
<span class="lineNum">     537 </span>            :     BOOST_FPE_ALL       = FE_ALL_EXCEPT,
<span class="lineNum">     538 </span>            : #else
<span class="lineNum">     539 </span>            :     BOOST_FPE_ALL       = BOOST_FPE_OFF,
<span class="lineNum">     540 </span>            : #endif
<span class="lineNum">     541 </span>            : 
<span class="lineNum">     542 </span>            : #endif /* *** */
<span class="lineNum">     543 </span>            :     BOOST_FPE_INV       = BOOST_FPE_ALL+1
<span class="lineNum">     544 </span>            : };
<span class="lineNum">     545 </span>            : 
<span class="lineNum">     546 </span>            : //____________________________________________________________________________//
<span class="lineNum">     547 </span>            : 
<span class="lineNum">     548 </span>            : // return the previous set of enabled exceptions when successful, and BOOST_FPE_INV otherwise
<span class="lineNum">     549 </span>            : unsigned BOOST_TEST_DECL enable( unsigned mask );
<span class="lineNum">     550 </span>            : unsigned BOOST_TEST_DECL disable( unsigned mask );
<span class="lineNum">     551 </span>            : 
<span class="lineNum">     552 </span>            : //____________________________________________________________________________//
<span class="lineNum">     553 </span>            : 
<span class="lineNum">     554 </span>            : } // namespace fpe
<span class="lineNum">     555 </span>            : 
<span class="lineNum">     556 </span>            : ///@}
<span class="lineNum">     557 </span>            : 
<span class="lineNum">     558 </span>            : }  // namespace boost
<span class="lineNum">     559 </span>            : 
<span class="lineNum">     560 </span>            : 
<span class="lineNum">     561 </span>            : #include &lt;boost/test/detail/enable_warnings.hpp&gt;
<span class="lineNum">     562 </span>            : 
<span class="lineNum">     563 </span>            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
